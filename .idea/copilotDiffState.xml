<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/setup/gltf_spawner.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/setup/gltf_spawner.rs" />
              <option name="originalContent" value="use bevy::prelude::*;&#10;use avian3d::prelude::*;&#10;#[cfg(feature = &quot;avian3d&quot;)]&#10;use avian3d::prelude::PhysicsDebugPlugin;&#10;&#10;/// Konfiguration für das Spawnen von GLTF-Modellen mit Physik (Builder Pattern)&#10;#[derive(Clone)]&#10;pub struct GltfSpawnConfig {&#10;    pub visual_gltf: Handle&lt;Gltf&gt;,&#10;    pub collider_gltf: Option&lt;Handle&lt;Gltf&gt;&gt;,&#10;    pub transform: Transform,&#10;    pub mass: f32,&#10;    pub restitution: f32,&#10;    pub friction: f32,&#10;    pub linear_velocity: Vec3,&#10;    pub angular_velocity: Vec3,&#10;    pub fallback_collider: Collider,&#10;    pub apply_radial_gravity: bool,&#10;}&#10;&#10;impl GltfSpawnConfig {&#10;    pub fn new(visual_gltf: Handle&lt;Gltf&gt;) -&gt; Self {&#10;        Self {&#10;            visual_gltf,&#10;            collider_gltf: None,&#10;            transform: Transform::default(),&#10;            mass: 100.0,&#10;            restitution: 0.0,&#10;            friction: 0.0,&#10;            linear_velocity: Vec3::ZERO,&#10;            angular_velocity: Vec3::ZERO,&#10;            fallback_collider: Collider::cylinder(0.15, 0.5),&#10;            apply_radial_gravity: false,&#10;        }&#10;    }&#10;&#10;    /// Builder-Methoden für einfache Konfiguration&#10;    pub fn with_collider_gltf(mut self, collider: Handle&lt;Gltf&gt;) -&gt; Self {&#10;        self.collider_gltf = Some(collider);&#10;        self&#10;    }&#10;&#10;    pub fn with_transform(mut self, transform: Transform) -&gt; Self {&#10;        self.transform = transform;&#10;        self&#10;    }&#10;&#10;    pub fn with_scale(mut self, scale: f32) -&gt; Self {&#10;        self.transform.scale = Vec3::splat(scale);&#10;        self&#10;    }&#10;&#10;    pub fn with_mass(mut self, mass: f32) -&gt; Self {&#10;        self.mass = mass;&#10;        self&#10;    }&#10;&#10;    pub fn with_physics(mut self, restitution: f32, friction: f32) -&gt; Self {&#10;        self.restitution = restitution;&#10;        self.friction = friction;&#10;        self&#10;    }&#10;&#10;    pub fn with_velocity(mut self, linear: Vec3, angular: Vec3) -&gt; Self {&#10;        self.linear_velocity = linear;&#10;        self.angular_velocity = angular;&#10;        self&#10;    }&#10;&#10;    pub fn with_radial_gravity(mut self, enabled: bool) -&gt; Self {&#10;        self.apply_radial_gravity = enabled;&#10;        self&#10;    }&#10;&#10;    pub fn with_fallback_collider(mut self, collider: Collider) -&gt; Self {&#10;        self.fallback_collider = collider;&#10;        self&#10;    }&#10;}&#10;&#10;pub fn spawn_gltf_with_physics(&#10;    commands: &amp;mut Commands,&#10;    gltf_assets: &amp;Assets&lt;Gltf&gt;,&#10;    gltf_mesh_assets: &amp;Assets&lt;bevy::gltf::GltfMesh&gt;,&#10;    mesh_assets: &amp;Assets&lt;Mesh&gt;,&#10;    config: GltfSpawnConfig,&#10;    uniform_scale: f32,&#10;    radial_gravity_marker: Option&lt;impl Component&gt;,&#10;) -&gt; Option&lt;Entity&gt; {&#10;    let visual_gltf = gltf_assets.get(&amp;config.visual_gltf)?;&#10;&#10;    info!(&quot; Spawning GLTF with physics, uniform_scale: {}&quot;, uniform_scale);&#10;&#10;    let collider = if let Some(collider_handle) = &amp;config.collider_gltf {&#10;        if let Some(collider_gltf) = gltf_assets.get(collider_handle) {&#10;            info!(&quot;  ↳ Using separate collider GLTF&quot;);&#10;            find_collider_in_gltf(collider_gltf, gltf_mesh_assets, mesh_assets, uniform_scale)&#10;                .unwrap_or_else(|| config.fallback_collider.clone())&#10;        } else {&#10;            warn!(&quot;  ⚠️ Collider GLTF not loaded yet, using fallback&quot;);&#10;            config.fallback_collider&#10;        }&#10;    } else {&#10;        info!(&quot;  ↳ No separate collider specified, trying visual mesh&quot;);&#10;        find_collider_in_gltf(visual_gltf, gltf_mesh_assets, mesh_assets, uniform_scale)&#10;            .unwrap_or_else(|| config.fallback_collider.clone())&#10;    };&#10;&#10;    let mut entity = commands.spawn((&#10;        SceneRoot(visual_gltf.scenes[0].clone()),&#10;        config.transform,&#10;        RigidBody::Dynamic,&#10;        collider,&#10;        Mass(config.mass),&#10;        Restitution::new(config.restitution),&#10;        Friction::new(config.friction),&#10;    ));&#10;&#10;    // Optional: Velocity&#10;    if config.linear_velocity != Vec3::ZERO {&#10;        entity.insert(LinearVelocity(config.linear_velocity));&#10;    }&#10;    if config.angular_velocity != Vec3::ZERO {&#10;        entity.insert(AngularVelocity(config.angular_velocity));&#10;    }&#10;&#10;    // Optional: Radiale Gravitation Marker (falls bereitgestellt)&#10;    if config.apply_radial_gravity {&#10;        if let Some(marker) = radial_gravity_marker {&#10;            entity.insert(marker);&#10;        }&#10;    }&#10;    Some(entity.id())&#10;}&#10;&#10;fn find_collider_in_gltf(&#10;    gltf: &amp;Gltf,&#10;    gltf_mesh_assets: &amp;Assets&lt;bevy::gltf::GltfMesh&gt;,&#10;    mesh_assets: &amp;Assets&lt;Mesh&gt;,&#10;    scale: f32,&#10;) -&gt; Option&lt;Collider&gt; {&#10;    for (node_name, _node_handle) in &amp;gltf.named_nodes {&#10;        let name_lower = node_name.to_lowercase();&#10;        if name_lower.contains(&quot;collider&quot;) || name_lower.contains(&quot;collision&quot;) || name_lower.contains(&quot;col_&quot;) {&#10;            info!(&quot; Found collider candidate node: {}&quot;, node_name);&#10;&#10;            if let Some(mesh_handle) = gltf.named_meshes.get(node_name) {&#10;                info!(&quot;  ↳ Found named_mesh handle for node: {}&quot;, node_name);&#10;                if let Some(gltf_mesh) = gltf_mesh_assets.get(mesh_handle) {&#10;                    info!(&quot;  ↳ GltfMesh found, primitives: {}&quot;, gltf_mesh.primitives.len());&#10;                    if let Some(primitive) = gltf_mesh.primitives.first() {&#10;                        if let Some(mesh) = mesh_assets.get(&amp;primitive.mesh) {&#10;                            info!(&quot;  ↳ Underlying Mesh asset present, trying ConvexHull...&quot;);&#10;                            let scaled_mesh = scale_mesh_vertices(mesh, scale);&#10;                            if let Some(collider) = Collider::convex_hull_from_mesh(&amp;scaled_mesh) {&#10;                                info!(&quot;✅ Created collider from node: {}&quot;, node_name);&#10;                                return Some(collider);&#10;                            } else {&#10;                                info!(&quot;⚠️ ConvexHull creation failed for node: {}&quot;, node_name);&#10;                            }&#10;                        } else {&#10;                            info!(&quot;⚠️ Mesh asset not yet available for primitive of node: {}&quot;, node_name);&#10;                        }&#10;                    } else {&#10;                        info!(&quot;⚠️ No primitives in GltfMesh for node: {}&quot;, node_name);&#10;                    }&#10;                } else {&#10;                    info!(&quot;⚠️ GltfMesh handle not yet resolved for node: {}&quot;, node_name);&#10;                }&#10;            } else {&#10;                info!(&quot;⚠️ Node '{}' has no entry in named_meshes&quot;, node_name);&#10;            }&#10;        }&#10;    }&#10;&#10;    for (mesh_name, mesh_handle) in &amp;gltf.named_meshes {&#10;        let name_lower = mesh_name.to_lowercase();&#10;        if name_lower.contains(&quot;collider&quot;) || name_lower.contains(&quot;collision&quot;) || name_lower.contains(&quot;col_&quot;) {&#10;            info!(&quot; Fallback: found named_mesh: {}&quot;, mesh_name);&#10;            if let Some(gltf_mesh) = gltf_mesh_assets.get(mesh_handle) {&#10;                info!(&quot;  ↳ GltfMesh found, primitives: {}&quot;, gltf_mesh.primitives.len());&#10;                if let Some(primitive) = gltf_mesh.primitives.first() {&#10;                    if let Some(mesh) = mesh_assets.get(&amp;primitive.mesh) {&#10;                        info!(&quot;  ↳ Underlying Mesh asset present, trying ConvexHull...&quot;);&#10;                        // Skaliere Mesh vor ConvexHull-Erstellung&#10;                        let scaled_mesh = scale_mesh_vertices(mesh, scale);&#10;                        if let Some(collider) = Collider::convex_hull_from_mesh(&amp;scaled_mesh) {&#10;                            info!(&quot;✅ Created collider from named_mesh: {}&quot;, mesh_name);&#10;                            return Some(collider);&#10;                        } else {&#10;                            info!(&quot;⚠️ ConvexHull creation failed for named_mesh: {}&quot;, mesh_name);&#10;                        }&#10;                    } else {&#10;                        info!(&quot;⚠️ Mesh asset not yet available for named_mesh: {}&quot;, mesh_name);&#10;                    }&#10;                } else {&#10;                    info!(&quot;⚠️ No primitives in GltfMesh for named_mesh: {}&quot;, mesh_name);&#10;                }&#10;            } else {&#10;                info!(&quot;⚠️ GltfMesh handle not yet resolved for named_mesh: {}&quot;, mesh_name);&#10;            }&#10;        }&#10;    }&#10;    info!(&quot; No collider found in GLTF (checked named_nodes + named_meshes).&quot;);&#10;    None&#10;}&#10;&#10;fn scale_mesh_vertices(mesh: &amp;Mesh, scale: f32) -&gt; Mesh {&#10;    let mut scaled_mesh = mesh.clone();&#10;&#10;    if let Some(positions_attr) = scaled_mesh.attribute(Mesh::ATTRIBUTE_POSITION) {&#10;        info!(&quot; Scaling mesh with factor: {}&quot;, scale);&#10;        let original_positions = positions_attr.as_float3().expect(&quot;Position attribute should be Float32x3&quot;);&#10;        info!(&quot;  ↳ Original mesh has {} vertices&quot;, original_positions.len());&#10;&#10;        // Berechne Bounding Box vor Skalierung&#10;        if let Some(first) = original_positions.first() {&#10;            let mut min = Vec3::new(first[0], first[1], first[2]);&#10;            let mut max = min;&#10;            for &amp;[x, y, z] in original_positions {&#10;                min = min.min(Vec3::new(x, y, z));&#10;                max = max.max(Vec3::new(x, y, z));&#10;            }&#10;            let size = max - min;&#10;            info!(&quot;  ↳ Original bounding box size: {:.3}, {:.3}, {:.3}&quot;, size.x, size.y, size.z);&#10;            info!(&quot;  ↳ After scaling will be: {:.3}, {:.3}, {:.3}&quot;, size.x * scale, size.y * scale, size.z * scale);&#10;        }&#10;&#10;        // Erstelle einen neuen Vec mit skalierten Positionen&#10;        let scaled_positions: Vec&lt;[f32; 3]&gt; = original_positions&#10;            .iter()&#10;            .map(|&amp;[x, y, z]| [x * scale, y * scale, z * scale])&#10;            .collect();&#10;&#10;        scaled_mesh.insert_attribute(Mesh::ATTRIBUTE_POSITION, scaled_positions);&#10;    } else {&#10;        warn!(&quot;⚠️ Mesh has no POSITION attribute!&quot;);&#10;     }&#10;     scaled_mesh&#10;}&#10;&#10;/// Spawnt ein einfaches Mesh (Primitive) mit Physik-Komponenten nach dem gleichen Muster wie GLTF&#10;pub fn spawn_primitive_with_physics(&#10;    commands: &amp;mut Commands,&#10;    mesh: Handle&lt;Mesh&gt;,&#10;    material: Handle&lt;StandardMaterial&gt;,&#10;    transform: Transform,&#10;    collider: Collider,&#10;    mass: f32,&#10;    restitution: f32,&#10;    friction: f32,&#10;    linear_velocity: Vec3,&#10;    angular_velocity: Vec3,&#10;    _uniform_scale: f32,&#10;    radial_gravity_marker: Option&lt;impl Component&gt;,&#10;) -&gt; Entity {&#10;    let mut entity = commands.spawn((&#10;        Mesh3d(mesh),&#10;        MeshMaterial3d(material),&#10;        transform,&#10;        RigidBody::Dynamic,&#10;        collider,&#10;        Mass(mass),&#10;        Restitution::new(restitution),&#10;        Friction::new(friction),&#10;    ));&#10;    if linear_velocity != Vec3::ZERO {&#10;        entity.insert(LinearVelocity(linear_velocity));&#10;    }&#10;    if angular_velocity != Vec3::ZERO {&#10;        entity.insert(AngularVelocity(angular_velocity));&#10;    }&#10;    if let Some(marker) = radial_gravity_marker {&#10;        entity.insert(marker);&#10;    }&#10;    entity.id()&#10;}&#10;&#10;/// Debug-System: Loggt Collider-Größen relativ zur Entfernung vom Zentrum&#10;pub fn debug_collider_distances(&#10;    query: Query&lt;(&amp;Transform, &amp;Collider), With&lt;RigidBody&gt;&gt;,&#10;    keyboard: Res&lt;ButtonInput&lt;KeyCode&gt;&gt;,&#10;) {&#10;    // Nur bei Tastendruck 'D'&#10;    if !keyboard.just_pressed(KeyCode::KeyD) {&#10;        return;&#10;    }&#10;&#10;    info!(&quot; === COLLIDER DEBUG INFO ===&quot;);&#10;    for (transform, _collider) in query.iter() {&#10;        let pos = transform.translation;&#10;        let distance_from_center = pos.length();&#10;        let scale = transform.scale;&#10;&#10;        info!(&quot;   Pos: ({:.2}, {:.2}, {:.2}), Distance: {:.2}, Scale: ({:.2}, {:.2}, {:.2})&quot;,&#10;            pos.x, pos.y, pos.z, distance_from_center, scale.x, scale.y, scale.z);&#10;    }&#10;}&#10;&#10;/// Toggle Collider-Visualisierung mit Taste 'V'&#10;pub fn toggle_physics_debug(&#10;    keyboard: Res&lt;ButtonInput&lt;KeyCode&gt;&gt;,&#10;    mut debug_config: ResMut&lt;PhysicsDebugConfig&gt;,&#10;) {&#10;    if keyboard.just_pressed(KeyCode::KeyV) {&#10;        debug_config.enabled = !debug_config.enabled;&#10;        if debug_config.enabled {&#10;            info!(&quot;️  Collider-Visualisierung AN&quot;);&#10;        } else {&#10;            info!(&quot; Collider-Visualisierung AUS&quot;);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="use bevy::prelude::*;&#10;use avian3d::prelude::*;&#10;&#10;/// Konfiguration für das Spawnen von GLTF-Modellen mit Physik (Builder Pattern)&#10;#[derive(Clone)]&#10;pub struct GltfSpawnConfig {&#10;    pub visual_gltf: Handle&lt;Gltf&gt;,&#10;    pub collider_gltf: Option&lt;Handle&lt;Gltf&gt;&gt;,&#10;    pub transform: Transform,&#10;    pub mass: f32,&#10;    pub restitution: f32,&#10;    pub friction: f32,&#10;    pub linear_velocity: Vec3,&#10;    pub angular_velocity: Vec3,&#10;    pub fallback_collider: Collider,&#10;    pub apply_radial_gravity: bool,&#10;}&#10;&#10;impl GltfSpawnConfig {&#10;    pub fn new(visual_gltf: Handle&lt;Gltf&gt;) -&gt; Self {&#10;        Self {&#10;            visual_gltf,&#10;            collider_gltf: None,&#10;            transform: Transform::default(),&#10;            mass: 100.0,&#10;            restitution: 0.0,&#10;            friction: 0.0,&#10;            linear_velocity: Vec3::ZERO,&#10;            angular_velocity: Vec3::ZERO,&#10;            fallback_collider: Collider::cylinder(0.15, 0.5),&#10;            apply_radial_gravity: false,&#10;        }&#10;    }&#10;&#10;    /// Builder-Methoden für einfache Konfiguration&#10;    pub fn with_collider_gltf(mut self, collider: Handle&lt;Gltf&gt;) -&gt; Self {&#10;        self.collider_gltf = Some(collider);&#10;        self&#10;    }&#10;&#10;    pub fn with_transform(mut self, transform: Transform) -&gt; Self {&#10;        self.transform = transform;&#10;        self&#10;    }&#10;&#10;    pub fn with_scale(mut self, scale: f32) -&gt; Self {&#10;        self.transform.scale = Vec3::splat(scale);&#10;        self&#10;    }&#10;&#10;    pub fn with_mass(mut self, mass: f32) -&gt; Self {&#10;        self.mass = mass;&#10;        self&#10;    }&#10;&#10;    pub fn with_physics(mut self, restitution: f32, friction: f32) -&gt; Self {&#10;        self.restitution = restitution;&#10;        self.friction = friction;&#10;        self&#10;    }&#10;&#10;    pub fn with_velocity(mut self, linear: Vec3, angular: Vec3) -&gt; Self {&#10;        self.linear_velocity = linear;&#10;        self.angular_velocity = angular;&#10;        self&#10;    }&#10;&#10;    pub fn with_radial_gravity(mut self, enabled: bool) -&gt; Self {&#10;        self.apply_radial_gravity = enabled;&#10;        self&#10;    }&#10;&#10;    pub fn with_fallback_collider(mut self, collider: Collider) -&gt; Self {&#10;        self.fallback_collider = collider;&#10;        self&#10;    }&#10;}&#10;&#10;pub fn spawn_gltf_with_physics(&#10;    commands: &amp;mut Commands,&#10;    gltf_assets: &amp;Assets&lt;Gltf&gt;,&#10;    gltf_mesh_assets: &amp;Assets&lt;bevy::gltf::GltfMesh&gt;,&#10;    mesh_assets: &amp;Assets&lt;Mesh&gt;,&#10;    config: GltfSpawnConfig,&#10;    _uniform_scale: f32, // Nicht mehr verwendet - Transform.scale übernimmt die Skalierung&#10;    radial_gravity_marker: Option&lt;impl Component&gt;,&#10;) -&gt; Option&lt;Entity&gt; {&#10;    let visual_gltf = gltf_assets.get(&amp;config.visual_gltf)?;&#10;&#10;    let collider = if let Some(collider_handle) = &amp;config.collider_gltf {&#10;        if let Some(collider_gltf) = gltf_assets.get(collider_handle) {&#10;            find_collider_in_gltf(collider_gltf, gltf_mesh_assets, mesh_assets)&#10;                .unwrap_or_else(|| config.fallback_collider.clone())&#10;        } else {&#10;            config.fallback_collider&#10;        }&#10;    } else {&#10;        find_collider_in_gltf(visual_gltf, gltf_mesh_assets, mesh_assets)&#10;            .unwrap_or_else(|| config.fallback_collider.clone())&#10;    };&#10;&#10;    let mut entity = commands.spawn((&#10;        SceneRoot(visual_gltf.scenes[0].clone()),&#10;        config.transform,&#10;        RigidBody::Dynamic,&#10;        collider,&#10;        Mass(config.mass),&#10;        Restitution::new(config.restitution),&#10;        Friction::new(config.friction),&#10;    ));&#10;&#10;    // Optional: Velocity&#10;    if config.linear_velocity != Vec3::ZERO {&#10;        entity.insert(LinearVelocity(config.linear_velocity));&#10;    }&#10;    if config.angular_velocity != Vec3::ZERO {&#10;        entity.insert(AngularVelocity(config.angular_velocity));&#10;    }&#10;&#10;    // Optional: Radiale Gravitation Marker (falls bereitgestellt)&#10;    if config.apply_radial_gravity {&#10;        if let Some(marker) = radial_gravity_marker {&#10;            entity.insert(marker);&#10;        }&#10;    }&#10;    Some(entity.id())&#10;}&#10;&#10;fn find_collider_in_gltf(&#10;    gltf: &amp;Gltf,&#10;    gltf_mesh_assets: &amp;Assets&lt;bevy::gltf::GltfMesh&gt;,&#10;    mesh_assets: &amp;Assets&lt;Mesh&gt;,&#10;) -&gt; Option&lt;Collider&gt; {&#10;    for (node_name, _node_handle) in &amp;gltf.named_nodes {&#10;        let name_lower = node_name.to_lowercase();&#10;        if name_lower.contains(&quot;collider&quot;) || name_lower.contains(&quot;collision&quot;) || name_lower.contains(&quot;col_&quot;) {&#10;            if let Some(mesh_handle) = gltf.named_meshes.get(node_name) {&#10;                if let Some(gltf_mesh) = gltf_mesh_assets.get(mesh_handle) {&#10;                    if let Some(primitive) = gltf_mesh.primitives.first() {&#10;                        if let Some(mesh) = mesh_assets.get(&amp;primitive.mesh) {&#10;                            let scaled_mesh = scale_mesh_vertices(mesh, 1.0);&#10;                            if let Some(collider) = Collider::convex_hull_from_mesh(&amp;scaled_mesh) {&#10;                                return Some(collider);&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    for (mesh_name, mesh_handle) in &amp;gltf.named_meshes {&#10;        let name_lower = mesh_name.to_lowercase();&#10;        if name_lower.contains(&quot;collider&quot;) || name_lower.contains(&quot;collision&quot;) || name_lower.contains(&quot;col_&quot;) {&#10;            if let Some(gltf_mesh) = gltf_mesh_assets.get(mesh_handle) {&#10;                if let Some(primitive) = gltf_mesh.primitives.first() {&#10;                    if let Some(mesh) = mesh_assets.get(&amp;primitive.mesh) {&#10;                        let scaled_mesh = scale_mesh_vertices(mesh, 1.0);&#10;                        if let Some(collider) = Collider::convex_hull_from_mesh(&amp;scaled_mesh) {&#10;                            return Some(collider);&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;    None&#10;}&#10;&#10;fn scale_mesh_vertices(mesh: &amp;Mesh, scale: f32) -&gt; Mesh {&#10;    let mut scaled_mesh = mesh.clone();&#10;&#10;    if let Some(positions_attr) = scaled_mesh.attribute(Mesh::ATTRIBUTE_POSITION) {&#10;        let original_positions = positions_attr.as_float3().expect(&quot;Position attribute should be Float32x3&quot;);&#10;        let scaled_positions: Vec&lt;[f32; 3]&gt; = original_positions&#10;            .iter()&#10;            .map(|&amp;[x, y, z]| [x * scale, y * scale, z * scale])&#10;            .collect();&#10;        scaled_mesh.insert_attribute(Mesh::ATTRIBUTE_POSITION, scaled_positions);&#10;    }&#10;&#10;    scaled_mesh&#10;}&#10;&#10;/// Spawnt ein einfaches Mesh (Primitive) mit Physik-Komponenten nach dem gleichen Muster wie GLTF&#10;pub fn spawn_primitive_with_physics(&#10;    commands: &amp;mut Commands,&#10;    mesh: Handle&lt;Mesh&gt;,&#10;    material: Handle&lt;StandardMaterial&gt;,&#10;    transform: Transform,&#10;    collider: Collider,&#10;    mass: f32,&#10;    restitution: f32,&#10;    friction: f32,&#10;    linear_velocity: Vec3,&#10;    angular_velocity: Vec3,&#10;    _uniform_scale: f32,&#10;    radial_gravity_marker: Option&lt;impl Component&gt;,&#10;) -&gt; Entity {&#10;    let mut entity = commands.spawn((&#10;        Mesh3d(mesh),&#10;        MeshMaterial3d(material),&#10;        transform,&#10;        RigidBody::Dynamic,&#10;        collider,&#10;        Mass(mass),&#10;        Restitution::new(restitution),&#10;        Friction::new(friction),&#10;    ));&#10;    if linear_velocity != Vec3::ZERO {&#10;        entity.insert(LinearVelocity(linear_velocity));&#10;    }&#10;    if angular_velocity != Vec3::ZERO {&#10;        entity.insert(AngularVelocity(angular_velocity));&#10;    }&#10;    if let Some(marker) = radial_gravity_marker {&#10;        entity.insert(marker);&#10;    }&#10;    entity.id()&#10;}&#10;&#10;/// Toggle Collider-Visualisierung mit Taste 'V'&#10;pub fn toggle_physics_debug(&#10;    keyboard: Res&lt;ButtonInput&lt;KeyCode&gt;&gt;,&#10;    mut gizmos_config: ResMut&lt;GizmoConfigStore&gt;,&#10;) {&#10;    if keyboard.just_pressed(KeyCode::KeyV) {&#10;        let (config, _) = gizmos_config.config_mut::&lt;PhysicsGizmos&gt;();&#10;        config.enabled = !config.enabled;&#10;        if config.enabled {&#10;            info!(&quot;️  Collider-Visualisierung AN&quot;);&#10;        } else {&#10;            info!(&quot; Collider-Visualisierung AUS&quot;);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/setup/stresstest.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/setup/stresstest.rs" />
              <option name="originalContent" value="use bevy::prelude::*;&#10;use crate::setup::assetloader::LoadedModels;&#10;use crate::setup::gltf_spawner::{GltfSpawnConfig, spawn_gltf_with_physics};&#10;use crate::setup::world::RadialGravity;&#10;use rand::Rng;&#10;&#10;/// Marker-Component für Stresstest-Objekte&#10;#[derive(Component)]&#10;pub struct StressTestObject;&#10;&#10;/// Resource zur Konfiguration des Stresstests&#10;#[derive(Resource)]&#10;pub struct StressTestConfig {&#10;    pub enabled: bool,&#10;    pub spawn_rate: f32,  // Objekte pro Sekunde&#10;    pub max_objects: usize,&#10;    pub spawn_timer: Timer,&#10;    pub current_count: usize,&#10;}&#10;&#10;impl Default for StressTestConfig {&#10;    fn default() -&gt; Self {&#10;        Self {&#10;            enabled: false,&#10;            spawn_rate: 10.0,  // 10 Objekte pro Sekunde&#10;            max_objects: 1000,&#10;            spawn_timer: Timer::from_seconds(0.1, TimerMode::Repeating),&#10;            current_count: 0,&#10;        }&#10;    }&#10;}&#10;&#10;/// Spawnt kontinuierlich neue Objekte für den Stresstest&#10;pub fn spawn_stress_test_objects(&#10;    mut commands: Commands,&#10;    loaded_models: Res&lt;LoadedModels&gt;,&#10;    gltf_assets: Res&lt;Assets&lt;Gltf&gt;&gt;,&#10;    gltf_mesh_assets: Res&lt;Assets&lt;bevy::gltf::GltfMesh&gt;&gt;,&#10;    mesh_assets: Res&lt;Assets&lt;Mesh&gt;&gt;,&#10;    time: Res&lt;Time&gt;,&#10;    mut config: ResMut&lt;StressTestConfig&gt;,&#10;) {&#10;    if !config.enabled || config.current_count &gt;= config.max_objects {&#10;        return;&#10;    }&#10;&#10;    config.spawn_timer.tick(time.delta());&#10;&#10;    if config.spawn_timer.just_finished() {&#10;        let mut rng = rand::rng();&#10;&#10;        // Wie viele Objekte spawnen wir diesen Frame?&#10;        let objects_to_spawn = (config.spawn_rate * config.spawn_timer.duration().as_secs_f32()) as usize;&#10;&#10;        for _ in 0..objects_to_spawn {&#10;            if config.current_count &gt;= config.max_objects {&#10;                break;&#10;            }&#10;&#10;            // Zufällige Position im Kreis über dem Boden&#10;            let angle = rng.random_range(0.0..std::f32::consts::TAU);&#10;            let radius = rng.random_range(0.0..30.0);&#10;            let x = angle.cos() * radius;&#10;            let z = angle.sin() * radius;&#10;            let y = rng.random_range(5.0..20.0);&#10;&#10;            // Zufällige Geschwindigkeit&#10;            let linear_vel = Vec3::new(&#10;                rng.random_range(-2.0..2.0),&#10;                rng.random_range(-1.0..1.0),&#10;                rng.random_range(-2.0..2.0),&#10;            );&#10;&#10;            let angular_vel = Vec3::new(&#10;                rng.random_range(-3.0..3.0),&#10;                rng.random_range(-3.0..3.0),&#10;                rng.random_range(-3.0..3.0),&#10;            );&#10;&#10;            // Zufällige Größe zwischen 50% und 150%&#10;            let scale = rng.random_range(0.5..1.5);&#10;&#10;            // BEST PRACTICE: Nutze generische spawn_gltf_with_physics Funktion&#10;            if let Some(tasse_handle) = &amp;loaded_models.tasse {&#10;                let spawn_config = GltfSpawnConfig::new(tasse_handle.clone())&#10;                    .with_collider_gltf(loaded_models.tasse_collider.clone().unwrap_or(tasse_handle.clone()))&#10;                    .with_transform(Transform::from_xyz(x, y, z))&#10;                    .with_scale(scale)&#10;                    .with_mass(0.2)&#10;                    .with_physics(0.0, 1.0)&#10;                    .with_velocity(linear_vel, angular_vel)&#10;                    .with_radial_gravity(true);&#10;&#10;                if let Some(entity) = spawn_gltf_with_physics(&#10;                    &amp;mut commands,&#10;                    &amp;gltf_assets,&#10;                    &amp;gltf_mesh_assets,&#10;                    &amp;mesh_assets,&#10;                    spawn_config,&#10;                    scale,  // uniform_scale Parameter&#10;                    Some(RadialGravity),&#10;                ) {&#10;                    // Füge noch den StressTestObject Marker hinzu&#10;                    commands.entity(entity).insert(StressTestObject);&#10;                }&#10;            }&#10;&#10;            config.current_count += 1;&#10;        }&#10;    }&#10;}&#10;&#10;/// Input-System um Stresstest zu steuern&#10;pub fn stress_test_input(&#10;    keyboard: Res&lt;ButtonInput&lt;KeyCode&gt;&gt;,&#10;    mut config: ResMut&lt;StressTestConfig&gt;,&#10;    query: Query&lt;Entity, With&lt;StressTestObject&gt;&gt;,&#10;    mut commands: Commands,&#10;) {&#10;    // T - Toggle Stresstest an/aus&#10;    if keyboard.just_pressed(KeyCode::KeyT) {&#10;        config.enabled = !config.enabled;&#10;        if config.enabled {&#10;            info!(&quot; Stresstest gestartet! (Max: {} Objekte, {} Obj/s)&quot;,&#10;                  config.max_objects, config.spawn_rate);&#10;        } else {&#10;            info!(&quot;⏸️  Stresstest pausiert&quot;);&#10;        }&#10;    }&#10;&#10;    // C - Clear alle Stresstest-Objekte&#10;    if keyboard.just_pressed(KeyCode::KeyC) {&#10;        for entity in query.iter() {&#10;            commands.entity(entity).despawn();&#10;        }&#10;        config.current_count = 0;&#10;        info!(&quot; Alle Stresstest-Objekte gelöscht&quot;);&#10;    }&#10;&#10;    // + - Spawn-Rate erhöhen&#10;    if keyboard.just_pressed(KeyCode::Equal) || keyboard.just_pressed(KeyCode::NumpadAdd) {&#10;        config.spawn_rate = (config.spawn_rate * 1.5).min(1000.0);&#10;        info!(&quot;⬆️  Spawn-Rate: {:.1} Obj/s&quot;, config.spawn_rate);&#10;    }&#10;&#10;    // - - Spawn-Rate verringern&#10;    if keyboard.just_pressed(KeyCode::Minus) || keyboard.just_pressed(KeyCode::NumpadSubtract) {&#10;        config.spawn_rate = (config.spawn_rate / 1.5).max(1.0);&#10;        info!(&quot;⬇️  Spawn-Rate: {:.1} Obj/s&quot;, config.spawn_rate);&#10;    }&#10;&#10;    // M - Max-Objekte erhöhen&#10;    if keyboard.just_pressed(KeyCode::KeyM) {&#10;        config.max_objects = (config.max_objects + 500).min(10000);&#10;        info!(&quot; Max Objekte: {}&quot;, config.max_objects);&#10;    }&#10;&#10;    // N - Max-Objekte verringern&#10;    if keyboard.just_pressed(KeyCode::KeyN) {&#10;        config.max_objects = (config.max_objects.saturating_sub(500)).max(100);&#10;        info!(&quot; Max Objekte: {}&quot;, config.max_objects);&#10;    }&#10;}&#10;&#10;/// Zeigt Stresstest-Info im Diagnostics-Overlay&#10;pub fn update_stress_test_info(&#10;    config: Res&lt;StressTestConfig&gt;,&#10;    query: Query&lt;&amp;StressTestObject&gt;,&#10;) {&#10;    // Wird nur alle paar Sekunden geloggt&#10;    if config.spawn_timer.just_finished() &amp;&amp; config.current_count % 50 == 0 {&#10;        let actual_count = query.iter().count();&#10;        if config.enabled {&#10;            info!(&quot; Stresstest: {}/{} Objekte aktiv&quot;,&#10;                  actual_count, config.max_objects);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="use bevy::prelude::*;&#10;use crate::setup::assetloader::LoadedModels;&#10;use crate::setup::gltf_spawner::{GltfSpawnConfig, spawn_gltf_with_physics};&#10;use crate::setup::world::RadialGravity;&#10;use rand::Rng;&#10;&#10;/// Marker-Component für Stresstest-Objekte&#10;#[derive(Component)]&#10;pub struct StressTestObject;&#10;&#10;/// Resource zur Konfiguration des Stresstests&#10;#[derive(Resource)]&#10;pub struct StressTestConfig {&#10;    pub enabled: bool,&#10;    pub spawn_rate: f32,  // Objekte pro Sekunde&#10;    pub max_objects: usize,&#10;    pub spawn_timer: Timer,&#10;    pub current_count: usize,&#10;}&#10;&#10;impl Default for StressTestConfig {&#10;    fn default() -&gt; Self {&#10;        Self {&#10;            enabled: false,&#10;            spawn_rate: 10.0,  // 10 Objekte pro Sekunde&#10;            max_objects: 1000,&#10;            spawn_timer: Timer::from_seconds(0.1, TimerMode::Repeating),&#10;            current_count: 0,&#10;        }&#10;    }&#10;}&#10;&#10;/// Spawnt kontinuierlich neue Objekte für den Stresstest&#10;pub fn spawn_stress_test_objects(&#10;    mut commands: Commands,&#10;    loaded_models: Res&lt;LoadedModels&gt;,&#10;    gltf_assets: Res&lt;Assets&lt;Gltf&gt;&gt;,&#10;    gltf_mesh_assets: Res&lt;Assets&lt;bevy::gltf::GltfMesh&gt;&gt;,&#10;    mesh_assets: Res&lt;Assets&lt;Mesh&gt;&gt;,&#10;    time: Res&lt;Time&gt;,&#10;    mut config: ResMut&lt;StressTestConfig&gt;,&#10;) {&#10;    if !config.enabled || config.current_count &gt;= config.max_objects {&#10;        return;&#10;    }&#10;&#10;    config.spawn_timer.tick(time.delta());&#10;&#10;    if config.spawn_timer.just_finished() {&#10;        let mut rng = rand::rng();&#10;&#10;        // Wie viele Objekte spawnen wir diesen Frame?&#10;        let objects_to_spawn = (config.spawn_rate * config.spawn_timer.duration().as_secs_f32()) as usize;&#10;&#10;        for _ in 0..objects_to_spawn {&#10;            if config.current_count &gt;= config.max_objects {&#10;                break;&#10;            }&#10;&#10;            // Zufällige Position im Kreis über dem Boden&#10;            let angle = rng.random_range(0.0..std::f32::consts::TAU);&#10;            let radius = rng.random_range(0.0..30.0);&#10;            let x = angle.cos() * radius;&#10;            let z = angle.sin() * radius;&#10;            let y = rng.random_range(5.0..20.0);&#10;&#10;            // Zufällige Geschwindigkeit&#10;            let linear_vel = Vec3::new(&#10;                rng.random_range(-2.0..2.0),&#10;                rng.random_range(-1.0..1.0),&#10;                rng.random_range(-2.0..2.0),&#10;            );&#10;&#10;            let angular_vel = Vec3::new(&#10;                rng.random_range(-3.0..3.0),&#10;                rng.random_range(-3.0..3.0),&#10;                rng.random_range(-3.0..3.0),&#10;            );&#10;&#10;            // Zufällige Größe mit größerer Variation: 20% bis 200%&#10;            let scale = rng.random_range(0.2..2.0);&#10;&#10;            // BEST PRACTICE: Nutze generische spawn_gltf_with_physics Funktion&#10;            if let Some(tasse_handle) = &amp;loaded_models.tasse {&#10;                let spawn_config = GltfSpawnConfig::new(tasse_handle.clone())&#10;                    .with_collider_gltf(loaded_models.tasse_collider.clone().unwrap_or(tasse_handle.clone()))&#10;                    .with_transform(Transform::from_xyz(x, y, z))&#10;                    .with_scale(scale)&#10;                    .with_mass(0.2)&#10;                    .with_physics(0.0, 1.0)&#10;                    .with_velocity(linear_vel, angular_vel)&#10;                    .with_radial_gravity(true);&#10;&#10;                if let Some(entity) = spawn_gltf_with_physics(&#10;                    &amp;mut commands,&#10;                    &amp;gltf_assets,&#10;                    &amp;gltf_mesh_assets,&#10;                    &amp;mesh_assets,&#10;                    spawn_config,&#10;                    scale,  // uniform_scale Parameter&#10;                    Some(RadialGravity),&#10;                ) {&#10;                    // Füge noch den StressTestObject Marker hinzu&#10;                    commands.entity(entity).insert(StressTestObject);&#10;                }&#10;            }&#10;&#10;            config.current_count += 1;&#10;        }&#10;    }&#10;}&#10;&#10;/// Input-System um Stresstest zu steuern&#10;pub fn stress_test_input(&#10;    keyboard: Res&lt;ButtonInput&lt;KeyCode&gt;&gt;,&#10;    mut config: ResMut&lt;StressTestConfig&gt;,&#10;    query: Query&lt;Entity, With&lt;StressTestObject&gt;&gt;,&#10;    mut commands: Commands,&#10;) {&#10;    // T - Toggle Stresstest an/aus&#10;    if keyboard.just_pressed(KeyCode::KeyT) {&#10;        config.enabled = !config.enabled;&#10;        if config.enabled {&#10;            info!(&quot; Stresstest gestartet! (Max: {} Objekte, {} Obj/s)&quot;,&#10;                  config.max_objects, config.spawn_rate);&#10;        } else {&#10;            info!(&quot;⏸️  Stresstest pausiert&quot;);&#10;        }&#10;    }&#10;&#10;    // C - Clear alle Stresstest-Objekte&#10;    if keyboard.just_pressed(KeyCode::KeyC) {&#10;        for entity in query.iter() {&#10;            commands.entity(entity).despawn();&#10;        }&#10;        config.current_count = 0;&#10;        info!(&quot; Alle Stresstest-Objekte gelöscht&quot;);&#10;    }&#10;&#10;    // + - Spawn-Rate erhöhen&#10;    if keyboard.just_pressed(KeyCode::Equal) || keyboard.just_pressed(KeyCode::NumpadAdd) {&#10;        config.spawn_rate = (config.spawn_rate * 1.5).min(1000.0);&#10;        info!(&quot;⬆️  Spawn-Rate: {:.1} Obj/s&quot;, config.spawn_rate);&#10;    }&#10;&#10;    // - - Spawn-Rate verringern&#10;    if keyboard.just_pressed(KeyCode::Minus) || keyboard.just_pressed(KeyCode::NumpadSubtract) {&#10;        config.spawn_rate = (config.spawn_rate / 1.5).max(1.0);&#10;        info!(&quot;⬇️  Spawn-Rate: {:.1} Obj/s&quot;, config.spawn_rate);&#10;    }&#10;&#10;    // M - Max-Objekte erhöhen&#10;    if keyboard.just_pressed(KeyCode::KeyM) {&#10;        config.max_objects = (config.max_objects + 500).min(10000);&#10;        info!(&quot; Max Objekte: {}&quot;, config.max_objects);&#10;    }&#10;&#10;    // N - Max-Objekte verringern&#10;    if keyboard.just_pressed(KeyCode::KeyN) {&#10;        config.max_objects = (config.max_objects.saturating_sub(500)).max(100);&#10;        info!(&quot; Max Objekte: {}&quot;, config.max_objects);&#10;    }&#10;}&#10;&#10;/// Zeigt Stresstest-Info im Diagnostics-Overlay&#10;pub fn update_stress_test_info(&#10;    config: Res&lt;StressTestConfig&gt;,&#10;    query: Query&lt;&amp;StressTestObject&gt;,&#10;) {&#10;    // Wird nur alle paar Sekunden geloggt&#10;    if config.spawn_timer.just_finished() &amp;&amp; config.current_count % 50 == 0 {&#10;        let actual_count = query.iter().count();&#10;        if config.enabled {&#10;            info!(&quot; Stresstest: {}/{} Objekte aktiv&quot;,&#10;                  actual_count, config.max_objects);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/setup/world.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/setup/world.rs" />
              <option name="originalContent" value="use bevy::prelude::*;&#10;use avian3d::prelude::*;&#10;use crate::setup::assetloader::LoadedModels;&#10;use crate::setup::gltf_spawner::{GltfSpawnConfig, spawn_gltf_with_physics, spawn_primitive_with_physics};&#10;&#10;pub fn spawn_world(&#10;    mut commands: Commands,&#10;    mut meshes: ResMut&lt;Assets&lt;Mesh&gt;&gt;,&#10;    mut materials: ResMut&lt;Assets&lt;StandardMaterial&gt;&gt;,&#10;) {&#10;    // commands.spawn((&#10;    //     RigidBody::Static,&#10;    //     Collider::cylinder(40.0, 0.1),&#10;    //     Mesh3d(meshes.add(Cylinder::new(40.0, 0.1))),&#10;    //     MeshMaterial3d(materials.add(Color::srgb_u8(100, 100, 100))),&#10;    //     Transform::from_xyz(0.0, 0.0, 0.0),&#10;    // ));&#10;}&#10;&#10;/// Marker-Component für Objekte mit radialer Gravitation&#10;#[derive(Component)]&#10;pub struct RadialGravity;&#10;&#10;/// System das radiale Gravitation zum Zentrum anwendet&#10;pub fn apply_radial_gravity(&#10;    mut query: Query&lt;(&amp;Transform, &amp;mut LinearVelocity), With&lt;RadialGravity&gt;&gt;,&#10;    time: Res&lt;Time&gt;,&#10;) {&#10;    let center = Vec3::ZERO;&#10;    let strength = 9.81;&#10;&#10;    for (transform, mut velocity) in query.iter_mut() {&#10;        let position = transform.translation;&#10;        let to_center = center - position;&#10;        let distance = to_center.length();&#10;&#10;        if distance &gt; 0.01 {&#10;            // Berechne Beschleunigung zum Zentrum&#10;            let gravity_accel = to_center.normalize() * strength;&#10;            // Addiere zur Geschwindigkeit&#10;            velocity.0 += gravity_accel * time.delta_secs();&#10;        }&#10;    }&#10;}&#10;&#10;/// Spawnt alle initialen Objekte, nachdem Assets geladen sind&#10;pub fn spawn_initial_objects(&#10;    mut commands: Commands,&#10;    mut meshes: ResMut&lt;Assets&lt;Mesh&gt;&gt;,&#10;    mut materials: ResMut&lt;Assets&lt;StandardMaterial&gt;&gt;,&#10;    loaded_models: Res&lt;LoadedModels&gt;,&#10;    gltf_assets: Res&lt;Assets&lt;Gltf&gt;&gt;,&#10;    gltf_mesh_assets: Res&lt;Assets&lt;bevy::gltf::GltfMesh&gt;&gt;,&#10;) {&#10;    info!(&quot; Spawning initial objects!&quot;);&#10;&#10;    // Spawne einen Würfel mit Physik über Helper&#10;    spawn_primitive_with_physics(&#10;        &amp;mut commands,&#10;        meshes.add(Cuboid::from_length(1.0)),&#10;        materials.add(Color::srgb_u8(0, 0, 0)),&#10;        Transform::from_xyz(0.0, 4.0, 0.0),&#10;        Collider::cuboid(1.0, 1.0, 1.0),&#10;        100.0,&#10;        0.0,&#10;        0.0,&#10;        Vec3::ZERO,&#10;        Vec3::new(0.1, 0.1, 0.1),&#10;        1.0,&#10;        Some(RadialGravity),&#10;    );&#10;&#10;    // BEST PRACTICE: Nutze generische spawn_gltf_with_physics Funktion&#10;    if let Some(tasse_handle) = &amp;loaded_models.tasse {&#10;        let scale = 0.5;&#10;        let config = GltfSpawnConfig::new(tasse_handle.clone())&#10;            // Nutze denselben Collider wie Stresstest&#10;            .with_collider_gltf(loaded_models.tasse_collider.clone().unwrap_or(tasse_handle.clone()))&#10;            // Verwende manuell einen Zylinder-Collider, bereits auf scale skaliert&#10;            .with_fallback_collider(Collider::cylinder(0.1 * scale, 0.2 * scale))&#10;            .with_transform(Transform::from_xyz(2.0, 2.0, 2.0))&#10;            .with_scale(scale)&#10;            .with_mass(1.0)&#10;            .with_physics(0.1, 0.2)  // Gleiche Physik wie Stresstest&#10;            .with_radial_gravity(true);&#10;&#10;        if let Some(entity) = spawn_gltf_with_physics(&#10;            &amp;mut commands,&#10;            &amp;gltf_assets,&#10;            &amp;gltf_mesh_assets,&#10;            &amp;meshes,&#10;            config,&#10;            scale,&#10;            Some(RadialGravity),&#10;        ) {&#10;            info!(&quot;☕ Tasse spawned with entity ID: {:?}&quot;, entity);&#10;        }&#10;    }&#10;&#10;    info!(&quot;✅ All initial objects spawned!&quot;);&#10;}&#10;" />
              <option name="updatedContent" value="use bevy::prelude::*;&#10;use avian3d::prelude::*;&#10;use crate::setup::assetloader::LoadedModels;&#10;use crate::setup::gltf_spawner::{GltfSpawnConfig, spawn_gltf_with_physics, spawn_primitive_with_physics};&#10;&#10;pub fn spawn_world(&#10;    mut commands: Commands,&#10;    mut meshes: ResMut&lt;Assets&lt;Mesh&gt;&gt;,&#10;    mut materials: ResMut&lt;Assets&lt;StandardMaterial&gt;&gt;,&#10;) {&#10;    // commands.spawn((&#10;    //     RigidBody::Static,&#10;    //     Collider::cylinder(40.0, 0.1),&#10;    //     Mesh3d(meshes.add(Cylinder::new(40.0, 0.1))),&#10;    //     MeshMaterial3d(materials.add(Color::srgb_u8(100, 100, 100))),&#10;    //     Transform::from_xyz(0.0, 0.0, 0.0),&#10;    // ));&#10;}&#10;&#10;/// Marker-Component für Objekte mit radialer Gravitation&#10;#[derive(Component)]&#10;pub struct RadialGravity;&#10;&#10;/// System das radiale Gravitation zum Zentrum anwendet&#10;pub fn apply_radial_gravity(&#10;    mut query: Query&lt;(&amp;Transform, &amp;mut LinearVelocity), With&lt;RadialGravity&gt;&gt;,&#10;    time: Res&lt;Time&gt;,&#10;) {&#10;    let center = Vec3::ZERO;&#10;    let strength = 9.81;&#10;&#10;    for (transform, mut velocity) in query.iter_mut() {&#10;        let position = transform.translation;&#10;        let to_center = center - position;&#10;        let distance = to_center.length();&#10;&#10;        if distance &gt; 0.01 {&#10;            // Berechne Beschleunigung zum Zentrum&#10;            let gravity_accel = to_center.normalize() * strength;&#10;            // Addiere zur Geschwindigkeit&#10;            velocity.0 += gravity_accel * time.delta_secs();&#10;        }&#10;    }&#10;}&#10;&#10;/// Spawnt alle initialen Objekte, nachdem Assets geladen sind&#10;pub fn spawn_initial_objects(&#10;    mut commands: Commands,&#10;    mut meshes: ResMut&lt;Assets&lt;Mesh&gt;&gt;,&#10;    mut materials: ResMut&lt;Assets&lt;StandardMaterial&gt;&gt;,&#10;    loaded_models: Res&lt;LoadedModels&gt;,&#10;    gltf_assets: Res&lt;Assets&lt;Gltf&gt;&gt;,&#10;    gltf_mesh_assets: Res&lt;Assets&lt;bevy::gltf::GltfMesh&gt;&gt;,&#10;) {&#10;    info!(&quot; Spawning initial objects!&quot;);&#10;&#10;    // Spawne einen Würfel mit Physik über Helper&#10;    spawn_primitive_with_physics(&#10;        &amp;mut commands,&#10;        meshes.add(Cuboid::from_length(1.0)),&#10;        materials.add(Color::srgb_u8(0, 0, 0)),&#10;        Transform::from_xyz(0.0, 4.0, 0.0),&#10;        Collider::cuboid(1.0, 1.0, 1.0),&#10;        100.0,&#10;        0.0,&#10;        0.0,&#10;        Vec3::ZERO,&#10;        Vec3::new(0.1, 0.1, 0.1),&#10;        1.0,&#10;        Some(RadialGravity),&#10;    );&#10;&#10;    // BEST PRACTICE: Nutze generische spawn_gltf_with_physics Funktion&#10;    if let Some(tasse_handle) = &amp;loaded_models.tasse {&#10;        let scale = 0.5;&#10;        let config = GltfSpawnConfig::new(tasse_handle.clone())&#10;            // Nutze denselben Collider wie Stresstest&#10;            .with_collider_gltf(loaded_models.tasse_collider.clone().unwrap_or(tasse_handle.clone()))&#10;            // Verwende einen SEHR kleinen Fallback-Collider zum Testen&#10;            .with_fallback_collider(Collider::cylinder(0.02, 0.05))&#10;            .with_transform(Transform::from_xyz(2.0, 2.0, 2.0))&#10;            .with_scale(scale)&#10;            .with_mass(1.0)&#10;            .with_physics(0.1, 0.2)  // Gleiche Physik wie Stresstest&#10;            .with_radial_gravity(true);&#10;&#10;        if let Some(entity) = spawn_gltf_with_physics(&#10;            &amp;mut commands,&#10;            &amp;gltf_assets,&#10;            &amp;gltf_mesh_assets,&#10;            &amp;meshes,&#10;            config,&#10;            scale,&#10;            Some(RadialGravity),&#10;        ) {&#10;            info!(&quot;☕ Tasse spawned with entity ID: {:?}&quot;, entity);&#10;        }&#10;    }&#10;&#10;    info!(&quot;✅ All initial objects spawned!&quot;);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>