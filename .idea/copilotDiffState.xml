<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/setup/mod.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/setup/mod.rs" />
              <option name="originalContent" value="pub mod world;&#10;pub mod lighting;&#10;pub mod camera;&#10;pub mod assetloader;&#10;pub mod appstate;&#10;pub mod diagnostics;&#10;pub mod stresstest;&#10;&#10;use bevy::prelude::*;&#10;use appstate::AppState;&#10;&#10;pub fn register_startup_systems(app: &amp;mut App) {&#10;    app.init_resource::&lt;stresstest::StressTestConfig&gt;();&#10;    app.init_resource::&lt;diagnostics::LowestFps&gt;();&#10;&#10;    app.add_systems(Startup, (&#10;        world::spawn_world,&#10;        lighting::spawn_ambient_light,&#10;        lighting::spawn_directional_light,&#10;        camera::spawn_default_camera,&#10;        diagnostics::setup_fps_overlay,&#10;        assetloader::load_assets_startup,&#10;    ));&#10;    // Environment Map Light erst spawnen, wenn wir in Running sind&#10;}&#10;&#10;pub fn register_update_systems(app: &amp;mut App) {&#10;    // Systems that run during Loading state&#10;    app.add_systems(&#10;        Update,&#10;        check_assets_loaded_transition.run_if(in_state(AppState::Loading))&#10;    );&#10;&#10;    // Systems that always run&#10;    app.add_systems(Update, (&#10;        diagnostics::update_fps_text,&#10;        diagnostics::update_average_fps_text,&#10;        diagnostics::update_lowest_fps_text,&#10;        diagnostics::update_state_text,&#10;        diagnostics::update_loading_progress,&#10;        diagnostics::update_stress_test_info_text,&#10;        stresstest::stress_test_input,&#10;        stresstest::update_stress_test_info,&#10;    ));&#10;&#10;    // Radiale Gravitation im Running state&#10;    app.add_systems(&#10;        Update,&#10;        world::apply_radial_gravity.run_if(in_state(AppState::Running))&#10;    );&#10;&#10;    // Systems that only run when Running&#10;    app.add_systems(&#10;        OnEnter(AppState::Running),&#10;        (&#10;            world::spawn_initial_objects,&#10;            lighting::spawn_environment_map_light,&#10;            setup_complete_log,&#10;        )&#10;    );&#10;&#10;    // Stresstest läuft nur im Running state&#10;    app.add_systems(&#10;        Update,&#10;        stresstest::spawn_stress_test_objects.run_if(in_state(AppState::Running))&#10;    );&#10;}&#10;&#10;fn setup_complete_log() {&#10;    info!(&quot; Setup complete - simulation starting!&quot;);&#10;}&#10;&#10;fn check_assets_loaded_transition(&#10;    asset_handles: Option&lt;Res&lt;crate::setup::assetloader::AssetHandles&gt;&gt;,&#10;    asset_server: Res&lt;AssetServer&gt;,&#10;    mut next_state: ResMut&lt;NextState&lt;AppState&gt;&gt;,&#10;) {&#10;    if let Some(handles_res) = asset_handles {&#10;        let handles = &amp;handles_res.0;&#10;        if handles.is_empty() {&#10;            info!(&quot;No assets to load, transitioning to Running&quot;);&#10;            next_state.set(AppState::Running);&#10;            return;&#10;        }&#10;&#10;        // Check if all assets are loaded&#10;        let all_loaded = handles.iter().all(|handle| {&#10;            matches!(&#10;                asset_server.get_load_state(handle.id()),&#10;                Some(bevy::asset::LoadState::Loaded)&#10;            )&#10;        });&#10;&#10;        if all_loaded {&#10;            info!(&quot;✅ All assets loaded successfully! Transitioning to Running state&quot;);&#10;            next_state.set(AppState::Running);&#10;        }&#10;    } else {&#10;        // No resource present; treat as no assets&#10;        info!(&quot;No asset handles found, transitioning to Running&quot;);&#10;        next_state.set(AppState::Running);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="pub mod world;&#10;pub mod lighting;&#10;pub mod camera;&#10;pub mod assetloader;&#10;pub mod appstate;&#10;pub mod diagnostics;&#10;pub mod stresstest;&#10;&#10;use bevy::prelude::*;&#10;use appstate::AppState;&#10;&#10;pub fn register_startup_systems(app: &amp;mut App) {&#10;    app.init_resource::&lt;stresstest::StressTestConfig&gt;();&#10;    app.init_resource::&lt;diagnostics::LowestFps&gt;();&#10;    app.init_resource::&lt;diagnostics::AverageFps&gt;();&#10;&#10;    app.add_systems(Startup, (&#10;        world::spawn_world,&#10;        lighting::spawn_ambient_light,&#10;        lighting::spawn_directional_light,&#10;        camera::spawn_default_camera,&#10;        diagnostics::setup_fps_overlay,&#10;        assetloader::load_assets_startup,&#10;    ));&#10;    // Environment Map Light erst spawnen, wenn wir in Running sind&#10;}&#10;&#10;pub fn register_update_systems(app: &amp;mut App) {&#10;    // Systems that run during Loading state&#10;    app.add_systems(&#10;        Update,&#10;        check_assets_loaded_transition.run_if(in_state(AppState::Loading))&#10;    );&#10;&#10;    // Systems that always run&#10;    app.add_systems(Update, (&#10;        diagnostics::update_fps_text,&#10;        diagnostics::update_average_fps_text,&#10;        diagnostics::update_lowest_fps_text,&#10;        diagnostics::update_state_text,&#10;        diagnostics::update_loading_progress,&#10;        diagnostics::update_stress_test_info_text,&#10;        stresstest::stress_test_input,&#10;        stresstest::update_stress_test_info,&#10;    ));&#10;&#10;    // Radiale Gravitation im Running state&#10;    app.add_systems(&#10;        Update,&#10;        world::apply_radial_gravity.run_if(in_state(AppState::Running))&#10;    );&#10;&#10;    // Systems that only run when Running&#10;    app.add_systems(&#10;        OnEnter(AppState::Running),&#10;        (&#10;            world::spawn_initial_objects,&#10;            lighting::spawn_environment_map_light,&#10;            setup_complete_log,&#10;        )&#10;    );&#10;&#10;    // Stresstest läuft nur im Running state&#10;    app.add_systems(&#10;        Update,&#10;        stresstest::spawn_stress_test_objects.run_if(in_state(AppState::Running))&#10;    );&#10;}&#10;&#10;fn setup_complete_log() {&#10;    info!(&quot; Setup complete - simulation starting!&quot;);&#10;}&#10;&#10;fn check_assets_loaded_transition(&#10;    asset_handles: Option&lt;Res&lt;crate::setup::assetloader::AssetHandles&gt;&gt;,&#10;    asset_server: Res&lt;AssetServer&gt;,&#10;    mut next_state: ResMut&lt;NextState&lt;AppState&gt;&gt;,&#10;) {&#10;    if let Some(handles_res) = asset_handles {&#10;        let handles = &amp;handles_res.0;&#10;        if handles.is_empty() {&#10;            info!(&quot;No assets to load, transitioning to Running&quot;);&#10;            next_state.set(AppState::Running);&#10;            return;&#10;        }&#10;&#10;        // Check if all assets are loaded&#10;        let all_loaded = handles.iter().all(|handle| {&#10;            matches!(&#10;                asset_server.get_load_state(handle.id()),&#10;                Some(bevy::asset::LoadState::Loaded)&#10;            )&#10;        });&#10;&#10;        if all_loaded {&#10;            info!(&quot;✅ All assets loaded successfully! Transitioning to Running state&quot;);&#10;            next_state.set(AppState::Running);&#10;        }&#10;    } else {&#10;        // No resource present; treat as no assets&#10;        info!(&quot;No asset handles found, transitioning to Running&quot;);&#10;        next_state.set(AppState::Running);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/setup/world.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/setup/world.rs" />
              <option name="originalContent" value="use bevy::prelude::*;&#10;use avian3d::prelude::*;&#10;use crate::setup::assetloader::LoadedModels;&#10;&#10;pub fn spawn_world(&#10;    mut commands: Commands,&#10;    mut meshes: ResMut&lt;Assets&lt;Mesh&gt;&gt;,&#10;    mut materials: ResMut&lt;Assets&lt;StandardMaterial&gt;&gt;,&#10;) {&#10;    commands.spawn((&#10;        RigidBody::Static,&#10;        Collider::cylinder(40.0, 0.1),&#10;        Mesh3d(meshes.add(Cylinder::new(40.0, 0.1))),&#10;        MeshMaterial3d(materials.add(Color::srgb_u8(100, 100, 100))),&#10;        Transform::from_xyz(0.0, 0.0, 0.0),&#10;    ));&#10;}&#10;&#10;/// Marker-Component für Objekte mit radialer Gravitation&#10;#[derive(Component)]&#10;pub struct RadialGravity;&#10;&#10;/// System das radiale Gravitation zum Zentrum anwendet&#10;pub fn apply_radial_gravity(&#10;    mut query: Query&lt;(&amp;Transform, &amp;mut LinearVelocity), With&lt;RadialGravity&gt;&gt;,&#10;    time: Res&lt;Time&gt;,&#10;) {&#10;    let center = Vec3::ZERO;&#10;    let strength = 9.81;&#10;&#10;    for (transform, mut velocity) in query.iter_mut() {&#10;        let position = transform.translation;&#10;        let to_center = center - position;&#10;        let distance = to_center.length();&#10;&#10;        if distance &gt; 0.01 {&#10;            // Berechne Beschleunigung zum Zentrum&#10;            let gravity_accel = to_center.normalize() * strength;&#10;            // Addiere zur Geschwindigkeit&#10;            velocity.0 += gravity_accel * time.delta_secs();&#10;        }&#10;    }&#10;}&#10;&#10;/// Spawnt alle initialen Objekte, nachdem Assets geladen sind&#10;pub fn spawn_initial_objects(&#10;    mut commands: Commands,&#10;    mut meshes: ResMut&lt;Assets&lt;Mesh&gt;&gt;,&#10;    mut materials: ResMut&lt;Assets&lt;StandardMaterial&gt;&gt;,&#10;    loaded_models: Res&lt;LoadedModels&gt;,&#10;    gltf_assets: Res&lt;Assets&lt;Gltf&gt;&gt;,&#10;    gltf_mesh_assets: Res&lt;Assets&lt;bevy::gltf::GltfMesh&gt;&gt;,&#10;) {&#10;    info!(&quot; Spawning initial objects!&quot;);&#10;&#10;    commands.spawn((&#10;        RigidBody::Dynamic,&#10;        Collider::cuboid(1.0, 1.0, 1.0),&#10;        Restitution::new(1.0),&#10;        Friction::new(0.75),&#10;        AngularVelocity(Vec3::new(2.5, 3.5, 1.5)),&#10;        Mesh3d(meshes.add(Cuboid::from_length(1.0))),&#10;        MeshMaterial3d(materials.add(Color::srgb_u8(255, 144, 255))),&#10;        Transform::from_xyz(0.0, 4.0, 0.0),&#10;        RadialGravity,&#10;    ));&#10;&#10;    // GLTF Modelle spawnen mit VEREINFACHTEM COLLIDER&#10;    if let Some(tasse_handle) = &amp;loaded_models.tasse {&#10;        if let Some(gltf) = gltf_assets.get(tasse_handle) {&#10;            // Versuche zuerst einen vereinfachten Collider-Mesh zu finden&#10;            // Namenskonvention: &quot;*_collider&quot; oder &quot;*_collision&quot;&#10;            let collider = find_collider_in_gltf(gltf, &amp;gltf_mesh_assets, &amp;meshes)&#10;                .unwrap_or_else(|| {&#10;                    info!(&quot;⚠️ Kein Collider-Mesh gefunden, verwende einfachen Cylinder&quot;);&#10;                    // VEREINFACHTER Collider - viel performanter als ConvexHull!&#10;                    Collider::cylinder(0.15, 0.5)&#10;                });&#10;&#10;            commands.spawn((&#10;                SceneRoot(gltf.scenes[0].clone()),&#10;                Transform::from_xyz(2.0, 2.0, 2.0),&#10;                RigidBody::Dynamic,&#10;                collider,&#10;                Restitution::new(0.5),&#10;                Friction::new(0.7),&#10;                RadialGravity,&#10;            ));&#10;            info!(&quot;☕ Tasse spawned with optimized collider!&quot;);&#10;        }&#10;    }&#10;&#10;    info!(&quot;✅ All initial objects spawned!&quot;);&#10;}&#10;&#10;/// Sucht nach einem Collider-Mesh im GLTF (by name convention)&#10;fn find_collider_in_gltf(&#10;    gltf: &amp;Gltf,&#10;    gltf_mesh_assets: &amp;Assets&lt;bevy::gltf::GltfMesh&gt;,&#10;    mesh_assets: &amp;Assets&lt;Mesh&gt;,&#10;) -&gt; Option&lt;Collider&gt; {&#10;    // Durchsuche alle Named Nodes nach Collider-Meshes&#10;    for (node_name, node_handle) in &amp;gltf.named_nodes {&#10;        let name_lower = node_name.to_lowercase();&#10;&#10;        // Check für Collider-Naming Convention&#10;        if name_lower.contains(&quot;collider&quot;) || name_lower.contains(&quot;collision&quot;) || name_lower.contains(&quot;col_&quot;) {&#10;            info!(&quot; Found collider mesh: {}&quot;, node_name);&#10;&#10;            // Versuche den Mesh aus diesem Node zu holen&#10;            if let Some(mesh_handle) = gltf.named_meshes.get(node_name) {&#10;                if let Some(gltf_mesh) = gltf_mesh_assets.get(mesh_handle) {&#10;                    if let Some(primitive) = gltf_mesh.primitives.first() {&#10;                        if let Some(mesh) = mesh_assets.get(&amp;primitive.mesh) {&#10;                            // Erstelle ConvexHull aus dem vereinfachten Mesh&#10;                            if let Some(collider) = Collider::convex_hull_from_mesh(mesh) {&#10;                                info!(&quot;✅ Created collider from: {}&quot;, node_name);&#10;                                return Some(collider);&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    None&#10;}&#10;" />
              <option name="updatedContent" value="use bevy::prelude::*;&#10;use avian3d::prelude::*;&#10;use crate::setup::assetloader::LoadedModels;&#10;&#10;pub fn spawn_world(&#10;    mut commands: Commands,&#10;    mut meshes: ResMut&lt;Assets&lt;Mesh&gt;&gt;,&#10;    mut materials: ResMut&lt;Assets&lt;StandardMaterial&gt;&gt;,&#10;) {&#10;    commands.spawn((&#10;        RigidBody::Static,&#10;        Collider::cylinder(40.0, 0.1),&#10;        Mesh3d(meshes.add(Cylinder::new(40.0, 0.1))),&#10;        MeshMaterial3d(materials.add(Color::srgb_u8(100, 100, 100))),&#10;        Transform::from_xyz(0.0, 0.0, 0.0),&#10;    ));&#10;}&#10;&#10;/// Marker-Component für Objekte mit radialer Gravitation&#10;#[derive(Component)]&#10;pub struct RadialGravity;&#10;&#10;/// System das radiale Gravitation zum Zentrum anwendet&#10;pub fn apply_radial_gravity(&#10;    mut query: Query&lt;(&amp;Transform, &amp;mut LinearVelocity), With&lt;RadialGravity&gt;&gt;,&#10;    time: Res&lt;Time&gt;,&#10;) {&#10;    let center = Vec3::ZERO;&#10;    let strength = 9.81;&#10;&#10;    for (transform, mut velocity) in query.iter_mut() {&#10;        let position = transform.translation;&#10;        let to_center = center - position;&#10;        let distance = to_center.length();&#10;&#10;        if distance &gt; 0.01 {&#10;            // Berechne Beschleunigung zum Zentrum&#10;            let gravity_accel = to_center.normalize() * strength;&#10;            // Addiere zur Geschwindigkeit&#10;            velocity.0 += gravity_accel * time.delta_secs();&#10;        }&#10;    }&#10;}&#10;&#10;/// Spawnt alle initialen Objekte, nachdem Assets geladen sind&#10;pub fn spawn_initial_objects(&#10;    mut commands: Commands,&#10;    mut meshes: ResMut&lt;Assets&lt;Mesh&gt;&gt;,&#10;    mut materials: ResMut&lt;Assets&lt;StandardMaterial&gt;&gt;,&#10;    loaded_models: Res&lt;LoadedModels&gt;,&#10;    gltf_assets: Res&lt;Assets&lt;Gltf&gt;&gt;,&#10;    gltf_mesh_assets: Res&lt;Assets&lt;bevy::gltf::GltfMesh&gt;&gt;,&#10;) {&#10;    info!(&quot; Spawning initial objects!&quot;);&#10;&#10;    commands.spawn((&#10;        RigidBody::Dynamic,&#10;        Collider::cuboid(1.0, 1.0, 1.0),&#10;        Restitution::new(1.0),&#10;        Friction::new(0.75),&#10;        AngularVelocity(Vec3::new(2.5, 3.5, 1.5)),&#10;        Mesh3d(meshes.add(Cuboid::from_length(1.0))),&#10;        MeshMaterial3d(materials.add(Color::srgb_u8(255, 144, 255))),&#10;        Transform::from_xyz(0.0, 4.0, 0.0),&#10;        RadialGravity,&#10;    ));&#10;&#10;    // GLTF Modelle spawnen mit VEREINFACHTEM COLLIDER&#10;    if let Some(tasse_handle) = &amp;loaded_models.tasse {&#10;        if let Some(gltf) = gltf_assets.get(tasse_handle) {&#10;            // Versuche zuerst einen vereinfachten Collider-Mesh zu finden&#10;            // Namenskonvention: &quot;*_collider&quot; oder &quot;*_collision&quot;&#10;            let collider = find_collider_in_gltf(gltf, &amp;gltf_mesh_assets, &amp;meshes)&#10;                .unwrap_or_else(|| {&#10;                    info!(&quot;⚠️ Kein Collider-Mesh gefunden, verwende einfachen Cylinder&quot;);&#10;                    // VEREINFACHTER Collider - viel performanter als ConvexHull!&#10;                    Collider::cylinder(0.15, 0.5)&#10;                });&#10;&#10;            commands.spawn((&#10;                SceneRoot(gltf.scenes[0].clone()),&#10;                Transform::from_xyz(2.0, 2.0, 2.0),&#10;                RigidBody::Dynamic,&#10;                collider,&#10;                Restitution::new(0.5),&#10;                Friction::new(0.7),&#10;                RadialGravity,&#10;            ));&#10;            info!(&quot;☕ Tasse spawned with optimized collider!&quot;);&#10;        }&#10;    }&#10;&#10;    info!(&quot;✅ All initial objects spawned!&quot;);&#10;}&#10;&#10;/// Sucht nach einem Collider-Mesh im GLTF (by name convention)&#10;fn find_collider_in_gltf(&#10;    gltf: &amp;Gltf,&#10;    gltf_mesh_assets: &amp;Assets&lt;bevy::gltf::GltfMesh&gt;,&#10;    mesh_assets: &amp;Assets&lt;Mesh&gt;,&#10;) -&gt; Option&lt;Collider&gt; {&#10;    // Durchsuche alle Named Nodes nach Collider-Meshes&#10;    for (node_name, _node_handle) in &amp;gltf.named_nodes {&#10;        let name_lower = node_name.to_lowercase();&#10;&#10;        // Check für Collider-Naming Convention&#10;        if name_lower.contains(&quot;collider&quot;) || name_lower.contains(&quot;collision&quot;) || name_lower.contains(&quot;col_&quot;) {&#10;            info!(&quot; Found collider mesh: {}&quot;, node_name);&#10;&#10;            // Versuche den Mesh aus diesem Node zu holen&#10;            if let Some(mesh_handle) = gltf.named_meshes.get(node_name) {&#10;                if let Some(gltf_mesh) = gltf_mesh_assets.get(mesh_handle) {&#10;                    if let Some(primitive) = gltf_mesh.primitives.first() {&#10;                        if let Some(mesh) = mesh_assets.get(&amp;primitive.mesh) {&#10;                            // Erstelle ConvexHull aus dem vereinfachten Mesh&#10;                            if let Some(collider) = Collider::convex_hull_from_mesh(mesh) {&#10;                                info!(&quot;✅ Created collider from: {}&quot;, node_name);&#10;                                return Some(collider);&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    None&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>