<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/setup/assetloader.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/setup/assetloader.rs" />
              <option name="originalContent" value="use bevy::asset::*;&#10;use bevy::prelude::*;&#10;use serde::Deserialize;&#10;use std::fs;&#10;use std::collections::HashMap;&#10;&#10;#[derive(Deserialize)]&#10;pub struct AssetSettings {&#10;    pub assets: AssetsConfig,&#10;}&#10;&#10;#[derive(Deserialize)]&#10;pub struct AssetsConfig {&#10;    pub audio: AudioConfig,&#10;    pub models: ModelsConfig,&#10;    pub environment: EnvironmentConfig,&#10;}&#10;&#10;#[derive(Deserialize)]&#10;pub struct AudioConfig {&#10;    pub sounds: HashMap&lt;String, String&gt;,&#10;    pub music: HashMap&lt;String, String&gt;,&#10;}&#10;&#10;#[derive(Deserialize)]&#10;pub struct ModelsConfig {&#10;    #[serde(flatten)]&#10;    pub models: HashMap&lt;String, String&gt;,&#10;}&#10;&#10;#[derive(Deserialize)]&#10;pub struct EnvironmentConfig {&#10;    pub map: String,&#10;}&#10;&#10;pub fn load_assets(settings: &amp;AssetSettings, asset_server: &amp;AssetServer) -&gt; Vec&lt;UntypedHandle&gt; {&#10;    let mut handles = Vec::new();&#10;&#10;    for sound in settings.assets.audio.sounds.values() {&#10;        info!(&quot;Loading audio asset: {}&quot;, sound);&#10;        let handle = asset_server.load::&lt;AudioSource&gt;(sound.clone()).untyped();&#10;        handles.push(handle);&#10;    }&#10;    for music in settings.assets.audio.music.values() {&#10;        info!(&quot;Loading music asset: {}&quot;, music);&#10;        let handle = asset_server.load::&lt;AudioSource&gt;(music.clone()).untyped();&#10;        handles.push(handle);&#10;    }&#10;&#10;    for (name, path) in &amp;settings.assets.models.models {&#10;        info!(&quot;Loading model '{}': {}&quot;, name, path);&#10;        let handle = asset_server.load::&lt;Gltf&gt;(path.clone()).untyped();&#10;        handles.push(handle);&#10;    }&#10;&#10;    // Load environment map&#10;    let env_map_path = &amp;settings.assets.environment.map;&#10;    info!(&quot;Loading environment map: {}&quot;, env_map_path);&#10;    let handle = asset_server.load::&lt;Image&gt;(env_map_path.clone()).untyped();&#10;    handles.push(handle);&#10;&#10;    handles&#10;}&#10;&#10;#[derive(Resource, Default)]&#10;pub struct AssetHandles(pub Vec&lt;UntypedHandle&gt;);&#10;&#10;/// Resource that stores typed handles for loaded models&#10;#[derive(Resource, Default)]&#10;pub struct LoadedModels {&#10;    pub tasse: Option&lt;Handle&lt;Gltf&gt;&gt;,&#10;    pub test: Option&lt;Handle&lt;Gltf&gt;&gt;,&#10;}&#10;&#10;/// Resource that stores the loaded asset settings for use by other systems&#10;#[derive(Resource, Clone)]&#10;pub struct LoadedAssetSettings {&#10;    pub environment_map_path: String,&#10;}&#10;&#10;/// Startup system: read config/settings.json, load assets and insert `AssetHandles` resource.&#10;pub fn load_assets_startup(mut commands: Commands, asset_server: Res&lt;AssetServer&gt;) {&#10;    let config_path = &quot;assets/config/settings.json&quot;;&#10;    match fs::read_to_string(config_path) {&#10;        Ok(contents) =&gt; match serde_json::from_str::&lt;AssetSettings&gt;(&amp;contents) {&#10;            Ok(settings) =&gt; {&#10;                let handles = load_assets(&amp;settings, &amp;asset_server);&#10;                info!(&quot;Requested {} assets to load&quot;, handles.len());&#10;                commands.insert_resource(AssetHandles(handles));&#10;&#10;                // Load and store typed model handles for easy access&#10;                let mut loaded_models = LoadedModels::default();&#10;&#10;                if let Some(tasse_path) = settings.assets.models.models.get(&quot;tasse&quot;) {&#10;                    loaded_models.tasse = Some(asset_server.load(tasse_path.clone()));&#10;                }&#10;                if let Some(test_path) = settings.assets.models.models.get(&quot;test&quot;) {&#10;                    loaded_models.test = Some(asset_server.load(test_path.clone()));&#10;                }&#10;&#10;                commands.insert_resource(loaded_models);&#10;&#10;                // Store the settings for use by other systems (e.g., lighting)&#10;                commands.insert_resource(LoadedAssetSettings {&#10;                    environment_map_path: settings.assets.environment.map.clone(),&#10;                });&#10;            }&#10;            Err(e) =&gt; {&#10;                warn!(&quot;Failed to parse {}: {}. No assets will be loaded.&quot;, config_path, e);&#10;                commands.insert_resource(AssetHandles::default());&#10;            }&#10;        },&#10;        Err(e) =&gt; {&#10;            warn!(&quot;Failed to read {}: {}. No assets will be loaded.&quot;, config_path, e);&#10;            commands.insert_resource(AssetHandles::default());&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="use bevy::asset::*;&#10;use bevy::prelude::*;&#10;use serde::Deserialize;&#10;use std::fs;&#10;use std::collections::HashMap;&#10;&#10;#[derive(Deserialize)]&#10;pub struct AssetSettings {&#10;    pub assets: AssetsConfig,&#10;}&#10;&#10;#[derive(Deserialize)]&#10;pub struct AssetsConfig {&#10;    pub audio: AudioConfig,&#10;    pub models: ModelsConfig,&#10;    pub environment: EnvironmentConfig,&#10;}&#10;&#10;#[derive(Deserialize)]&#10;pub struct AudioConfig {&#10;    pub sounds: HashMap&lt;String, String&gt;,&#10;    pub music: HashMap&lt;String, String&gt;,&#10;}&#10;&#10;#[derive(Deserialize)]&#10;pub struct ModelsConfig {&#10;    #[serde(flatten)]&#10;    pub models: HashMap&lt;String, String&gt;,&#10;}&#10;&#10;#[derive(Deserialize)]&#10;pub struct EnvironmentConfig {&#10;    pub map: String,&#10;}&#10;&#10;pub fn load_assets(settings: &amp;AssetSettings, asset_server: &amp;AssetServer) -&gt; Vec&lt;UntypedHandle&gt; {&#10;    let mut handles = Vec::new();&#10;&#10;    for sound in settings.assets.audio.sounds.values() {&#10;        info!(&quot;Loading audio asset: {}&quot;, sound);&#10;        let handle = asset_server.load::&lt;AudioSource&gt;(sound.clone()).untyped();&#10;        handles.push(handle);&#10;    }&#10;    for music in settings.assets.audio.music.values() {&#10;        info!(&quot;Loading music asset: {}&quot;, music);&#10;        let handle = asset_server.load::&lt;AudioSource&gt;(music.clone()).untyped();&#10;        handles.push(handle);&#10;    }&#10;&#10;    for (name, path) in &amp;settings.assets.models.models {&#10;        info!(&quot;Loading model '{}': {}&quot;, name, path);&#10;        let handle = asset_server.load::&lt;Gltf&gt;(path.clone()).untyped();&#10;        handles.push(handle);&#10;    }&#10;&#10;    // Load environment map&#10;    let env_map_path = &amp;settings.assets.environment.map;&#10;    info!(&quot;Loading environment map: {}&quot;, env_map_path);&#10;    let handle = asset_server.load::&lt;Image&gt;(env_map_path.clone()).untyped();&#10;    handles.push(handle);&#10;&#10;    handles&#10;}&#10;&#10;#[derive(Resource, Default)]&#10;pub struct AssetHandles(pub Vec&lt;UntypedHandle&gt;);&#10;&#10;/// Resource that stores typed handles for loaded models&#10;#[derive(Resource, Default)]&#10;pub struct LoadedModels {&#10;    pub tasse: Option&lt;Handle&lt;Gltf&gt;&gt;,&#10;    pub test: Option&lt;Handle&lt;Gltf&gt;&gt;,&#10;}&#10;&#10;/// Resource that stores the loaded asset settings for use by other systems&#10;#[derive(Resource, Clone)]&#10;pub struct LoadedAssetSettings {&#10;    pub environment_map_path: String,&#10;}&#10;&#10;/// Startup system: read config/settings.json, load assets and insert `AssetHandles` resource.&#10;pub fn load_assets_startup(mut commands: Commands, asset_server: Res&lt;AssetServer&gt;) {&#10;    let config_path = &quot;assets/config/settings.json&quot;;&#10;    match fs::read_to_string(config_path) {&#10;        Ok(contents) =&gt; match serde_json::from_str::&lt;AssetSettings&gt;(&amp;contents) {&#10;            Ok(settings) =&gt; {&#10;                info!(&quot;Starting to load assets...&quot;);&#10;                let handles = load_assets(&amp;settings, &amp;asset_server);&#10;                info!(&quot;Requested {} assets to load&quot;, handles.len());&#10;                commands.insert_resource(AssetHandles(handles));&#10;&#10;                // Load and store typed model handles for easy access&#10;                let mut loaded_models = LoadedModels::default();&#10;&#10;                if let Some(tasse_path) = settings.assets.models.models.get(&quot;tasse&quot;) {&#10;                    info!(&quot;Queueing load for tasse: {}&quot;, tasse_path);&#10;                    loaded_models.tasse = Some(asset_server.load(tasse_path.clone()));&#10;                }&#10;                &#10;                if let Some(test_path) = settings.assets.models.models.get(&quot;test&quot;) {&#10;                    info!(&quot;Queueing load for test: {}&quot;, test_path);&#10;                    loaded_models.test = Some(asset_server.load(test_path.clone()));&#10;                }&#10;&#10;                commands.insert_resource(loaded_models);&#10;&#10;                // Store the settings for use by other systems (e.g., lighting)&#10;                commands.insert_resource(LoadedAssetSettings {&#10;                    environment_map_path: settings.assets.environment.map.clone(),&#10;                });&#10;                info!(&quot;Asset loading queued successfully&quot;);&#10;            }&#10;            Err(e) =&gt; {&#10;                warn!(&quot;Failed to parse {}: {}. No assets will be loaded.&quot;, config_path, e);&#10;                commands.insert_resource(AssetHandles::default());&#10;            }&#10;        },&#10;        Err(e) =&gt; {&#10;            warn!(&quot;Failed to read {}: {}. No assets will be loaded.&quot;, config_path, e);&#10;            commands.insert_resource(AssetHandles::default());&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/setup/mod.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/setup/mod.rs" />
              <option name="originalContent" value="pub mod world;&#10;pub mod lighting;&#10;pub mod camera;&#10;pub mod assetloader;&#10;pub mod gamestates;&#10;&#10;use bevy::prelude::*;&#10;use bevy::input::ButtonInput;&#10;use crate::setup::gamestates::GameState;&#10;&#10;pub fn register_startup_systems(app: &amp;mut App) {&#10;    app.add_systems(Startup, (&#10;        world::spawn_world,&#10;        lighting::spawn_ambient_light,&#10;        lighting::spawn_directional_light,&#10;        camera::spawn_camera,&#10;        assetloader::load_assets_startup,&#10;    ));&#10;&#10;    // Spawn environment map after assets are loaded&#10;    app.add_systems(PostStartup, lighting::spawn_environment_map_light);&#10;}&#10;&#10;/// Simple, explicit state-machine example implemented as a Resource.&#10;/// - `register_state_systems` installs the resource and the demo systems.&#10;pub fn register_state_systems(app: &amp;mut App) {&#10;    app.insert_resource(AppState::new(GameState::Loading));&#10;&#10;    app.add_systems(Update, (&#10;        loading_timer_system,&#10;        input_transition_system,&#10;        state_debug_system,&#10;        check_assets_loaded_system,&#10;        world::spawn_loaded_models,  // Spawnt Modelle, wenn sie bereit sind&#10;    ));&#10;}&#10;&#10;#[derive(Resource)]&#10;pub struct AppState {&#10;    pub state: GameState,&#10;    loading_timer: Timer,&#10;    last_reported: Option&lt;GameState&gt;,&#10;}&#10;&#10;impl AppState {&#10;    pub fn new(initial: GameState) -&gt; Self {&#10;        AppState {&#10;            state: initial,&#10;            loading_timer: Timer::from_seconds(2.0, TimerMode::Once),&#10;            last_reported: None,&#10;        }&#10;    }&#10;}&#10;&#10;fn loading_timer_system(time: Res&lt;Time&gt;, mut app_state: ResMut&lt;AppState&gt;) {&#10;    if app_state.state == GameState::Loading {&#10;        app_state.loading_timer.tick(time.delta());&#10;        if app_state.loading_timer.is_finished() {&#10;            app_state.state = GameState::Menu;&#10;            // reset timer in case we re-enter Loading later&#10;            app_state.loading_timer = Timer::from_seconds(2.0, TimerMode::Once);&#10;        }&#10;    }&#10;}&#10;&#10;fn input_transition_system(&#10;    keyboard: Res&lt;ButtonInput&lt;KeyCode&gt;&gt;,&#10;    mut app_state: ResMut&lt;AppState&gt;,&#10;) {&#10;    // Space : toggle between Menu and InGame&#10;    if keyboard.just_pressed(KeyCode::Space) {&#10;        match app_state.state {&#10;            GameState::Menu =&gt; app_state.state = GameState::InGame,&#10;            GameState::InGame =&gt; app_state.state = GameState::Paused,&#10;            GameState::Paused =&gt; app_state.state = GameState::InGame,&#10;            _ =&gt; {}&#10;        }&#10;    }&#10;&#10;    // Esc : go to Menu from any state&#10;    if keyboard.just_pressed(KeyCode::Escape) {&#10;        app_state.state = GameState::Menu;&#10;    }&#10;}&#10;&#10;fn state_debug_system(mut app_state: ResMut&lt;AppState&gt;) {&#10;    if app_state.last_reported != Some(app_state.state) {&#10;        info!(&quot;AppState changed: {:?}&quot;, app_state.state);&#10;        app_state.last_reported = Some(app_state.state);&#10;    }&#10;}&#10;&#10;// Check if all assets from AssetHandles are loaded. If yes, transition to Menu.&#10;fn check_assets_loaded_system(&#10;    asset_handles: Option&lt;Res&lt;crate::setup::assetloader::AssetHandles&gt;&gt;,&#10;    asset_server: Res&lt;AssetServer&gt;,&#10;    mut app_state: ResMut&lt;AppState&gt;,&#10;) {&#10;    // only act while in Loading&#10;    if app_state.state != GameState::Loading {&#10;        return;&#10;    }&#10;&#10;    if let Some(handles_res) = asset_handles {&#10;        let handles = &amp;handles_res.0;&#10;        if handles.is_empty() {&#10;            // nothing to load -&gt; go to Menu&#10;            app_state.state = GameState::Menu;&#10;            return;&#10;        }&#10;        // Check if all assets are loaded&#10;        let all_loaded = handles.iter().all(|handle| {&#10;            matches!(&#10;                asset_server.get_load_state(handle.id()),&#10;                Some(bevy::asset::LoadState::Loaded)&#10;            )&#10;        });&#10;        if all_loaded {&#10;            app_state.state = GameState::Menu;&#10;        }&#10;    } else {&#10;        // No resource present; treat as no assets&#10;        app_state.state = GameState::Menu;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="pub mod world;&#10;pub mod lighting;&#10;pub mod camera;&#10;pub mod assetloader;&#10;pub mod gamestates;&#10;&#10;use bevy::prelude::*;&#10;use bevy::input::ButtonInput;&#10;use crate::setup::gamestates::GameState;&#10;&#10;pub fn register_startup_systems(app: &amp;mut App) {&#10;    app.add_systems(Startup, (&#10;        world::spawn_world,&#10;        lighting::spawn_ambient_light,&#10;        lighting::spawn_directional_light,&#10;        camera::spawn_camera,&#10;        assetloader::load_assets_startup,&#10;    ));&#10;&#10;    // Spawn environment map after assets are loaded&#10;    app.add_systems(PostStartup, lighting::spawn_environment_map_light);&#10;}&#10;&#10;/// Simple, explicit state-machine example implemented as a Resource.&#10;/// - `register_state_systems` installs the resource and the demo systems.&#10;pub fn register_state_systems(app: &amp;mut App) {&#10;    app.insert_resource(AppState::new(GameState::Loading));&#10;&#10;    app.add_systems(Update, (&#10;        loading_timer_system,&#10;        check_assets_loaded_system,&#10;        input_transition_system,&#10;        state_debug_system,&#10;    ));&#10;    &#10;    // Spawn models nur wenn wir im InGame State sind UND Assets geladen sind&#10;    app.add_systems(Update, &#10;        world::spawn_loaded_models&#10;            .run_if(resource_exists::&lt;crate::setup::assetloader::LoadedModels&gt;)&#10;            .run_if(in_state(GameState::InGame))&#10;    );&#10;}&#10;&#10;#[derive(Resource)]&#10;pub struct AppState {&#10;    pub state: GameState,&#10;    loading_timer: Timer,&#10;    last_reported: Option&lt;GameState&gt;,&#10;}&#10;&#10;impl AppState {&#10;    pub fn new(initial: GameState) -&gt; Self {&#10;        AppState {&#10;            state: initial,&#10;            loading_timer: Timer::from_seconds(2.0, TimerMode::Once),&#10;            last_reported: None,&#10;        }&#10;    }&#10;}&#10;&#10;fn loading_timer_system(time: Res&lt;Time&gt;, mut app_state: ResMut&lt;AppState&gt;) {&#10;    if app_state.state == GameState::Loading {&#10;        app_state.loading_timer.tick(time.delta());&#10;        if app_state.loading_timer.is_finished() {&#10;            app_state.state = GameState::Menu;&#10;            // reset timer in case we re-enter Loading later&#10;            app_state.loading_timer = Timer::from_seconds(2.0, TimerMode::Once);&#10;        }&#10;    }&#10;}&#10;&#10;fn input_transition_system(&#10;    keyboard: Res&lt;ButtonInput&lt;KeyCode&gt;&gt;,&#10;    mut app_state: ResMut&lt;AppState&gt;,&#10;) {&#10;    // Space : toggle between Menu and InGame&#10;    if keyboard.just_pressed(KeyCode::Space) {&#10;        match app_state.state {&#10;            GameState::Menu =&gt; app_state.state = GameState::InGame,&#10;            GameState::InGame =&gt; app_state.state = GameState::Paused,&#10;            GameState::Paused =&gt; app_state.state = GameState::InGame,&#10;            _ =&gt; {}&#10;        }&#10;    }&#10;&#10;    // Esc : go to Menu from any state&#10;    if keyboard.just_pressed(KeyCode::Escape) {&#10;        app_state.state = GameState::Menu;&#10;    }&#10;}&#10;&#10;fn state_debug_system(mut app_state: ResMut&lt;AppState&gt;) {&#10;    if app_state.last_reported != Some(app_state.state) {&#10;        info!(&quot;AppState changed: {:?}&quot;, app_state.state);&#10;        app_state.last_reported = Some(app_state.state);&#10;    }&#10;}&#10;&#10;// Check if all assets from AssetHandles are loaded. If yes, transition to Menu.&#10;fn check_assets_loaded_system(&#10;    asset_handles: Option&lt;Res&lt;crate::setup::assetloader::AssetHandles&gt;&gt;,&#10;    asset_server: Res&lt;AssetServer&gt;,&#10;    mut app_state: ResMut&lt;AppState&gt;,&#10;) {&#10;    // only act while in Loading&#10;    if app_state.state != GameState::Loading {&#10;        return;&#10;    }&#10;&#10;    if let Some(handles_res) = asset_handles {&#10;        let handles = &amp;handles_res.0;&#10;        if handles.is_empty() {&#10;            // nothing to load -&gt; go to Menu&#10;            app_state.state = GameState::Menu;&#10;            return;&#10;        }&#10;        // Check if all assets are loaded&#10;        let all_loaded = handles.iter().all(|handle| {&#10;            matches!(&#10;                asset_server.get_load_state(handle.id()),&#10;                Some(bevy::asset::LoadState::Loaded)&#10;            )&#10;        });&#10;        if all_loaded {&#10;            app_state.state = GameState::Menu;&#10;        }&#10;    } else {&#10;        // No resource present; treat as no assets&#10;        app_state.state = GameState::Menu;&#10;    }&#10;}&#10;&#10;fn in_state(state: GameState) -&gt; impl FnMut(Res&lt;AppState&gt;) -&gt; bool {&#10;    move |app_state: Res&lt;AppState&gt;| app_state.state == state&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>